use std::mem;
use std::fmt;

use crate::vm::{ADDRESS_SIZE, HANDLED_SIZE_SPECIFIER, REGISTER_ID_SIZE};


macro_rules! declare_bytecodes {
    ($($name:ident ($args_size:expr) $( + $additional_non_const_size:expr)?),+) => {       

/// Represents the byte code instruction set
#[derive(Debug, Clone, Copy)]
#[allow(dead_code, non_camel_case_types)]
#[repr(u8)]
pub enum ByteCodes {
    $($name),+
}

impl ByteCodes {

    /// Get the name of the instruction.
    pub fn name(&self) -> &'static str {
        match self {
            $(Self::$name => stringify!($name),)+
        }
    }


    /// Get the size in bytes of the arguments that the instruction requires.
    /// Some instructions require a variable number of bytes as arguments determined by the handled size specifier byte.
    /// For this reason, this function fails if the input arguments are malformed.
    pub fn args_size(&self, bytecode_after: &[u8]) -> Result<usize, ()> {
        match self {
            $(Self::$name => Ok(
                $args_size $( + *bytecode_after.first().ok_or(())? as usize * $additional_non_const_size )?
            ),)+
        }
    }

}

    };
}


const NO_ARGS: usize = 0;
const NON_CONST_SIZE: usize = 1;
const NON_CONST_SIZE_DOUBLE: usize = 2;


declare_bytecodes! {

    INTEGER_ADD (NO_ARGS),
    INTEGER_SUB (NO_ARGS),
    INTEGER_MUL (NO_ARGS),
    INTEGER_DIV (NO_ARGS),
    INTEGER_MOD (NO_ARGS),

    FLOAT_ADD (NO_ARGS),
    FLOAT_SUB (NO_ARGS),
    FLOAT_MUL (NO_ARGS),
    FLOAT_DIV (NO_ARGS),
    FLOAT_MOD (NO_ARGS),

    INC_REG (REGISTER_ID_SIZE),
    INC_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE),
    INC_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE),

    DEC_REG (REGISTER_ID_SIZE),
    DEC_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE),
    DEC_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE),

    NO_OPERATION (NO_ARGS),

    MOVE_INTO_REG_FROM_REG (REGISTER_ID_SIZE + REGISTER_ID_SIZE),
    MOVE_INTO_REG_FROM_REG_SIZED (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE + REGISTER_ID_SIZE),
    MOVE_INTO_REG_FROM_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE + REGISTER_ID_SIZE),
    MOVE_INTO_REG_FROM_CONST (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE) + NON_CONST_SIZE,
    MOVE_INTO_REG_FROM_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE + ADDRESS_SIZE),
    MOVE_INTO_ADDR_IN_REG_FROM_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE + REGISTER_ID_SIZE),
    MOVE_INTO_ADDR_IN_REG_FROM_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE + REGISTER_ID_SIZE),
    MOVE_INTO_ADDR_IN_REG_FROM_CONST (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE) + NON_CONST_SIZE,
    MOVE_INTO_ADDR_IN_REG_FROM_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE + ADDRESS_SIZE),
    MOVE_INTO_ADDR_LITERAL_FROM_REG (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE + REGISTER_ID_SIZE),
    MOVE_INTO_ADDR_LITERAL_FROM_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE + REGISTER_ID_SIZE),
    MOVE_INTO_ADDR_LITERAL_FROM_CONST (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE) + NON_CONST_SIZE,
    MOVE_INTO_ADDR_LITERAL_FROM_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE + ADDRESS_SIZE),

    PUSH_FROM_REG (REGISTER_ID_SIZE),
    PUSH_FROM_REG_SIZED (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE),
    PUSH_FROM_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE),
    PUSH_FROM_CONST (HANDLED_SIZE_SPECIFIER) + NON_CONST_SIZE,
    PUSH_FROM_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE),

    PUSH_STACK_POINTER_REG (REGISTER_ID_SIZE),
    PUSH_STACK_POINTER_REG_SIZED (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE),
    PUSH_STACK_POINTER_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE),
    PUSH_STACK_POINTER_CONST (HANDLED_SIZE_SPECIFIER) + NON_CONST_SIZE,
    PUSH_STACK_POINTER_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE),

    POP_INTO_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE),
    POP_INTO_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE),
    POP_INTO_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE),

    POP_STACK_POINTER_REG (REGISTER_ID_SIZE),
    POP_STACK_POINTER_REG_SIZED (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE),
    POP_STACK_POINTER_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE),
    POP_STACK_POINTER_CONST (HANDLED_SIZE_SPECIFIER) + NON_CONST_SIZE,
    POP_STACK_POINTER_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE),

    LABEL (NO_ARGS),

    JUMP (ADDRESS_SIZE),
    JUMP_NOT_ZERO (ADDRESS_SIZE),
    JUMP_ZERO (ADDRESS_SIZE),
    JUMP_GREATER (ADDRESS_SIZE),
    JUMP_LESS (ADDRESS_SIZE),
    JUMP_GREATER_OR_EQUAL (ADDRESS_SIZE),
    JUMP_LESS_OR_EQUAL (ADDRESS_SIZE),
    JUMP_CARRY (ADDRESS_SIZE),
    JUMP_NOT_CARRY (ADDRESS_SIZE),
    JUMP_OVERFLOW (ADDRESS_SIZE),
    JUMP_NOT_OVERFLOW (ADDRESS_SIZE),
    JUMP_SIGN (ADDRESS_SIZE),
    JUMP_NOT_SIGN (ADDRESS_SIZE),

    CALL  (ADDRESS_SIZE),
    RETURN (NO_ARGS),

    COMPARE_REG_REG (REGISTER_ID_SIZE + REGISTER_ID_SIZE),
    COMPARE_REG_REG_SIZED (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE + REGISTER_ID_SIZE),
    COMPARE_REG_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE + REGISTER_ID_SIZE),
    COMPARE_REG_CONST (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE) + NON_CONST_SIZE,
    COMPARE_REG_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE + ADDRESS_SIZE),
    COMPARE_ADDR_IN_REG_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE + REGISTER_ID_SIZE),
    COMPARE_ADDR_IN_REG_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE + REGISTER_ID_SIZE),
    COMPARE_ADDR_IN_REG_CONST (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE) + NON_CONST_SIZE,
    COMPARE_ADDR_IN_REG_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE + ADDRESS_SIZE),
    COMPARE_CONST_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE) + NON_CONST_SIZE,
    COMPARE_CONST_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + REGISTER_ID_SIZE) + NON_CONST_SIZE,
    COMPARE_CONST_CONST (HANDLED_SIZE_SPECIFIER) + NON_CONST_SIZE_DOUBLE,
    COMPARE_CONST_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE) + NON_CONST_SIZE,
    COMPARE_ADDR_LITERAL_REG (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE + REGISTER_ID_SIZE),
    COMPARE_ADDR_LITERAL_ADDR_IN_REG (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE + REGISTER_ID_SIZE),
    COMPARE_ADDR_LITERAL_CONST (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE) + NON_CONST_SIZE,
    COMPARE_ADDR_LITERAL_ADDR_LITERAL (HANDLED_SIZE_SPECIFIER + ADDRESS_SIZE + ADDRESS_SIZE),

    AND (NO_ARGS),
    OR (NO_ARGS),
    XOR (NO_ARGS),
    NOT (NO_ARGS),
    SHIFT_LEFT (NO_ARGS),
    SHIFT_RIGHT (NO_ARGS),

    INTERRUPT (NO_ARGS),

    EXIT (NO_ARGS)

}


pub const BYTE_CODE_COUNT: usize = mem::variant_count::<ByteCodes>();


impl fmt::Display for ByteCodes {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.name())
    }
}


impl std::convert::From<u8> for ByteCodes {

    fn from(value: u8) -> Self {
        if value < BYTE_CODE_COUNT as u8 {
            unsafe { std::mem::transmute(value) }
        } else {
            panic!("Invalid byte code: {}", value);
        }
    }
}


/// Return whether the given instruction is a jump instruction
pub fn is_jump_instruction(instruction: ByteCodes) -> bool {
    ByteCodes::JUMP as usize <= instruction as usize && instruction as usize <= ByteCodes::RETURN as usize
}

